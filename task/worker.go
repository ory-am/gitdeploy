package task

import (
	"fmt"
	"github.com/ory-am/event"
	"github.com/ory-am/gitdeploy/sse"
	"time"
)

// Task is a function which runs a task, for example "flynn create app" or "git clone"
type Task func(w WorkerLog) error

// TaskList is a queue of Tasks
type TaskList map[string]Task

// WorkerLog
type WorkerLog chan *workerEvent

type workerEvent struct {
	message string
	err     error
	// offset should be int32 or float64
	offset  time.Time
}

// Add adds an event to the channel
func (w WorkerLog) Add(message string) {
	go func() {
		w <- &workerEvent{
			message: message,
			err:     nil,
			offset:  time.Now(),
		}
	}()
}

// Add adds an error event to the channel
func (w WorkerLog) AddError(err error) {
	go func() {
		w <- &workerEvent{
			message: fmt.Sprintf("An error occured: %s", err.Error()),
			err:     err,
			offset:  time.Now(),
		}
	}()
}

// RunJob sequentially runs all tasks in the TaskList using the FIFO scheduling algorithm.
// Output generated by a task are forwarded to the event manager and eventually
// to all listeners, like the storage backend or the logger.
// When one of the tasks returns an error, RunJob will abort all queued tasks and return the error.
func RunJob(workerChan WorkerLog, channel string, em *event.EventManager, taskList TaskList) (err error) {
	// Run all jobs
	errChan := make(chan error)
	for ev, task := range taskList {
		// Forward output to the event manager
		go func(ev string) {
			for {
				select {
				case v, open := <-workerChan:
					if !open {
						return
					}
					em.TriggerAndWait(ev, sse.NewEvent(channel, v.message, ev))
				}
			}
		}(ev)

		// Run next task
		go func() {
			defer close(workerChan)
			defer close(errChan)
			errChan <- task(workerChan)
		}()

		// Catch errors if any occur
		for {
			select {
			case err := <-errChan:
				return err
			}
		}
	}
	return nil
}
